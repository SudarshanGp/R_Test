/**

How this works...
- parse actual routes, and store parsed routes in the routeCollection
- parse main express file for requires, filter the requires to
 local files only
 compare required files with routeCollection to find the appropriate
 files that are needed for routes
- watch main file for modifcation, and re-parse

**/
var mode = module.parent.exports.settings.env;
if (mode === 'development') {
console.log('~ Refreshing routes');

var debug = false
	,	path = require('path')
	,	fs = require('fs')
	, app_file = module.parent.filename
	,	app_path = path.dirname(module.parent.filename) + '/'
	// file parser
	, parseFile = require('./lib/parser.js')
	// own route object implementation
	,	Route = require('./lib/route.js')
	// collection (array) of own route objects
	,	routeCollection = []
	// array for what files to track
	,	filesToTrack = []
	// array for what files are already being tracked, main file is always tracked
	,	trackedFiles = {app_file: true};

/**
	* Calls the parser
	*	Takes route and require statements found by parser
	*	and converts that information into "proper" route objects
	* Then adds it to the route collection
**/
var buildRoutes = function(){
	// temporary arrays to store all parsed routes and files
	var tmpRoutes = []
		,	tmpFiles = [];
	// clear routeCollection before we (re)build
	routeCollection = [];
	// clear files to track and (re)build
	filesToTrack = [];
	
	// takes a counter to not parse too deep or even an infinite loop
	var parse = function(file, counter, cb){
		//console.log(tmpRoutes);
		//console.log(tmpFiles);
		debug_print('parse called on ' + file);
		parseFile(file, function(proutes, pfiles){
			proutes.forEach(function(r){
				tmpRoutes.unshift(r);
			});

			// parse every other file imported
			pfiles.forEach(function(f){
				// has an issue with resolving paths that are not within
				// the main app file's dir
				var f_path = fixPath(f.filePath);
				if (f_path) {
					// doesn't ensure unique, need to be unique !
					tmpFiles.unshift(f);
					debug_print(counter);
					// track files that are required by the main file
					if (counter === 0) filesToTrack.unshift(f.filePath);
					if (counter < 2) parse(f_path, counter + 1, cb);
				};
			});
			
			cb();
		});
	}
	
	parse(app_file, 0, function(){
		buildTracking();
		// process all tmp routes
		tmpRoutes.forEach(function(routeObj){
			process(routeObj, tmpFiles);
		});
	});
}

var process = function(routeObj, knownFiles){
	// convert object literal to a proper Route object
	var rroute = new Route(routeObj);
	// re-define callbacks, from a array of string
	// to an array of objects
	for (var i = 0, rLen = rroute.callbacks.length; i < rLen; i++) {
		// Does it have a prefix? if not, its a main file function
		// if there is, find the actual function and assign it to
		// the route object
		if (rroute.callbacks[i].prefix) {
			// match known required files with route
			knownFiles.forEach(function(file){
				if (file.varName == rroute.callbacks[i].prefix) rroute.callbacks[i].file = file.filePath;
			});
		};
	};
	routeCollection.unshift(rroute);
}

/**
	*	(Re)build files to track
	* compares filesToTrack with trackedFiles for differences
*/
var buildTracking = function(){
	filesToTrack.forEach(function(file){
		var f = fixPath(file);
		if (!trackedFiles[f]) {
			debug_print('now tracking file: ' + f);
			trackedFiles[f] = true;
			track(f);
		};
	});
}

/**
	*	Look up a route in routeCollection
*/
var lookupRoute = function(method, path){
	var retRoute;
	routeCollection.forEach(function(route){
		if (route.method === method && route.path === path){
			retRoute = route;
		};
	});
	return retRoute;
}

/**
	*	fixes path in relation to modules cache
	* not aSync at the moment :(
*/
var fixPath = function(file_path){
	var p = path.resolve(app_path + file_path);
	try {
		var stat = fs.statSync(p);
		// is it a directory?
		if (stat.isDirectory()) {
			// fix trailing /
			var trailing;
			if (p[-1] !== '/') { trailing = '/'; };
			// append and assume index.js if it's a directory
			p = p + trailing + 'index.js';
		};
		return p;
	} catch(e) {
		// no such file
		return false;
	};
}

var debug_print = function(arg){
	if (debug) console.log(arg);
}

var track = function(f){
	fs.watchFile(f, {persistent: true, interval: 500}, function(curr, prev){
		if (curr.mtime.getTime() !== prev.mtime.getTime()) {
			// check if it's the main app file
			if (f !== app_file) { delete(require.cache[f]); };
			require(f);
			buildRoutes();
		};
	});
}

// not really used at the moment
var untrack = function(f){
	fs.unwatchFile(f, {persistent: true, interval: 500}, function(curr, prev){
		
	});
}

module.exports = function(){
	buildRoutes();
	// always track main file
	track(app_file);

	return function(req, res, next){
		var routeObj = req.app.routes._match(req, 0);
		// Can express Router find a route?
		if (routeObj) {
			var cachedRoute = lookupRoute(routeObj.method, routeObj.path);
			// Does it have a callback from our routeCollection?
			if (cachedRoute){
				// delete old route and cache(s)
				// then re-declare route and require files
				req.app.remove(routeObj.path);
			
				var routes;
				var route_callbacks = [];
				
				// rebuild route callbacks
				for (var i = 0; i < cachedRoute.callbacks.length; i++) {
					var cb = cachedRoute.callbacks[i];
					if (cb.prefix) {
						var cb_path = fixPath(cb.file);

						// not going to clear cache here, clear it when file is modified
						//delete(require.cache[cb_path]);
						routes = require(cb_path);
						route_callbacks.push(routes[cb.suffix]);
					} else {
						// no prefix, means function exists in the main file			
						// this doesn't work since the function isn't exported
						//route_callbacks.unshift(req.app[cb]);
						
						// so instead, we look at the 'original' route and
						// point to the original function, which won't be refreshed
						route_callbacks.push(routeObj.callbacks[i]);
					};
				};

				req.app[routeObj.method](routeObj.path, route_callbacks);
			};
		};
		next();
	};
};
	
} else { module.exports = function() { return function(req,res,next){ next(); } } };